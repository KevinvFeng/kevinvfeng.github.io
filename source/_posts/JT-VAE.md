---
title: JT-VAE
date: 2021-06-02 14:50:21
author: Kevin Feng
tags:
- Machine Learning
- Molecule Generation
- Molecule Optimization
---
JT-VAE通过利用 juction tree 以及原子图模型解决了分子生成中生成无效分子的问题
<!--more-->
## 写在前面
本篇所介绍的模型,并不需要完全掌握细节,因为就现在 2021 年来看其实这个代码稍微有些过时, 实际效果也并没有那么理想, 所以具体细节不是很重要. 但是作者考虑的将分子图拆解出来的方法是完全可以借鉴思考的,这一部分作者思考的深度是有的.
## 其他模型的问题
作者提出了两个在以往基于 SMILES 的生成模型中存在的问题:
1. Smiles 编码不能帮助人们以及计算机了解分子之间的相似性,如图所示. 换句话说,SMILES 就不是用来表示相似性的.
    ![](JT-VAE-issue-1.png)
    > 作者的例子我觉得不好,因为没有将两个分子做归一化处理, 如果不做的话,相同的分子都可以有差异很大的SMILES表示. 图中给的例子做了归一化处理之后差异就很小了. 但是可以参考附录中的例子,那个例子显示的SMILES都是用openbabel归一化之后的.
2. 在分子有效性等其他化学指标上,用图表示比用 smiles 更容易一点. 当然这是作者的假设,不过是有道理的\
   
## 解决方案
因为上述的两个问题,所以作者采用了图的方法来做分子生成

## 如果用图会带来什么新问题?
个人理解,其实对于有机分子来说,只要不是环,那分子还是挺像一个计算机学中的图的,但是如果有了苯环等其他环,这个图的处理就会比较麻烦.所以核心还是在怎么处理环上.
对于环简单的办法就是把苯环或者其他的环都看成一个整体,跟原子的地位相当.
![](graph2tree-1.png)
如图所示,这就是作者把图变成树的示例.
具体这是怎么变成树的,回头再讲.

## 除了树,还有别的吗?
除了树,作者也存储了所有关于节点的信息
这一部分基本上就是图算法了

## 整体流程
1. 从 SMIELS 搞出图以及 junction tree. 之后分成两步走,一步是 Junction Tree 另一部分是 Atom Graph.
![](Encoder-Structure.png)

### Junction Tree
从图先通过 Tree Decomposition 生成一个树,之后再将这个树表示成图

#### Tree Decomposition 
![](Tree-decomp.png)
![](remove-bridge-ring.png)
![](remove-ring.png)
![](mst.png)
1. 通过 rdkit 给分子进行编号 
2. 通过 rdkit 统计所有的不成环的边以及所有的环
3. 将拥有三个及以上共同原子的环连接起来看做一个环(避免桥环). 此处如果仅有两个共同原子则为并环
4. 通过添加节点的方式解决不成环边共享共同原子的在图中成环的方式
5. 通过最小生成树算法搞出一个图
   
至此我们成功的将一个图转化成了一个树

#### Tree -> $Z_T$
![](build-vocab.png)
![](gru.png)
![](node-agg.png)
1. 找到 root 节点,root 节点是0 号原子所在的基团
2. 先 bottom-up 从最下方的叶子节点向上走传播,传播用的方式是 GRU. 对于一个 Node 如果拥有两个 child-node 则 GRU 会同时引入两个点的 hidden vector之和.
3. 再 top-down. bottom-up+top-down结合相当于完成了一个树的遍历,这一部分从图的思想会比较容易理解,正向传播以及反向重新传播一次.
4. 之后我们根据图的每个Node, 共同求和得到了Z_T_message(__注意__ 这个地方表示的是树的整体)
5. 同样我们再根据顶点(root)的信息得到了Z_tree 这个Z于上面的Z_T_message是有区别的.二者共同结合得到了Junction-Tree的Z.
   
### Graph
Graph 相较 Tree Decomposition 多少还是容易一点的.
对于一个分子图,我们能获取到的信息有:
- 原子特征
- 化学键特征
- 原子之间的邻接表
- 化学键的邻接表
通过以上四种信息的组合可以得到分子图这边的表示信息.
![](graph.png)

#### 原子特征
表示原子的特征有如下几类:
- 原子是什么
- 原子用了几个键
- 电荷数
- 有没有手性
- 是否是成芳香环
![](af.png)
将这几个特征拼起来就是原子的特征

#### 化学键特征
同样有多个类来表示化学键
- 键的类型
- 顺反异构
拼接起来就是键的类型
![](bf.png)

#### 图的特征
通过邻接矩阵,表示一个图,这部分仅仅是为了存储信息并用于标识图传播算法的方向,并不会计算特征. 相当于一个lookup table.
![](ag.png)
![](bg.png)

### 计算图特征的方式
树的计算方式和图的计算方式都差不多,可以参考前面的图.本质上就是通过MPN转2圈.
关于为什么转两圈,作者这里认为重复传播两次已经足够了,但是实时是不是这样并不一定.只是普遍意义上认为MPN重复循环的传播会导致整个图比较converge.

### 中场休息
上文中我们得到了三个Z, Junction-Tree中两个+图的一个Z_G. 接下来将要利用这三个Z做Decoder.
详尽代码这里不做讨论,但是需要抓住的重点有如下两个:

### 生成骨架
![](td.png)
如图所示,生成骨架采用DFS(深度优先搜索)的方式. 首先从root开始, 按如下流程作出决策
1. 是否需要产生新的节点
   1. 如果是,产生什么节点.
   2. 如果不是,向反方向传播
   
以图片为例:
首先从1节点开始,需要产生2就从1->2进行一次传播.2节点判断需要产生3节点. 到3节点,判断不需要产生新的节点,就从3->2进行一次传播. 2继续判断需要产生4节点. 如此往复知道树已经生成完了.
个人理解用图作为提取结构的方法到这里才得到充分体现. 我们可以很方便的去生成一个完整的树,但是如果改成图生成起来就会非常困难.图的遍历不如树来的简单直观,便于计算.

### 生成细节,判断构象
![](score.png)
除了生成骨架,另一个需要注意的细节是,作者是如何让模型判断应该如何拼接分子的. 比如苯环有六个可以接入的点,那么如何选择正确的结合点就是黑心问题了.
作者的解决思路如下:
1. 先从树的结构中判断拼接什么片段,以及大致接在什么位置
2. 产生遍历产生所有可能的拼接情况
3. 通过rdkti判断那些情况合法,哪些情况不合法
4. 对所有合法的情况进行一次打分,选择打分较高的作为最终的生成方案. 
5. 重复以上步骤直到所有的树节点都构建完成得到最终分子
   
### Loss Function
关于Loss Function除了VAE本身的recon_loss+kl_loss以外,作者还因为采用了JT以及图的形式使用了其他的Loss具体有:
- word_loss
- topo_loss
- assm_loss
- stereo_loss(可选)
- kl_loss
- prop_loss

## 参考资料
- [Junction Tree Variational Autoencoder for Molecular Graph Generation](https://arxiv.org/abs/1802.04364)
- [Slides From TDLS](https://github.com/treeforever/tdls.github.io/blob/master/slides/20180924_RouzbehAfrasiabi.pdf) 

## 附录
- 归一化的SMILES
![](JT-VAE-issue-2.jpg)